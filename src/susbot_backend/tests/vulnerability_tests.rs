use susbot_backend::{
    analysis::analyze_source_code,
    extract_true_source_code,
    structs::EtherscanApiResponse,
};

fn mock_single_file_response() -> EtherscanApiResponse {
    let json = r#"
    {
        "status": "1",
        "message": "OK",
        "result": [
            {
                "SourceCode": "pragma solidity ^0.8.0; contract Vulnerable { function kill() public { selfdestruct(payable(msg.sender)); } }",
                "ABI": "Contract-ABI",
                "ContractName": "Vulnerable",
                "CompilerVersion": "v0.8.20+commit.a1b79de6",
                "OptimizationUsed": "1",
                "Runs": "200",
                "ConstructorArguments": "",
                "EVMVersion": "Default",
                "Library": "",
                "LicenseType": "MIT",
                "Proxy": "0",
                "Implementation": "",
                "SwarmSource": "ipfs://..."
            }
        ]
    }
    "#;
    serde_json::from_str(json).unwrap()
}

#[test]
fn test_analysis_with_single_file_source() {
    let mock_response = mock_single_file_response();
    let source_code = extract_true_source_code(&mock_response.result[0].source_code);
    let analysis_result = analyze_source_code(&source_code);

    assert!(analysis_result.risks.iter().any(|r| r.check_name == "Self-Destruct"));
    assert_eq!(analysis_result.score, 30); // 100 - 70 (Critical)
    assert_eq!(analysis_result.risks.len(), 1);
    assert_eq!(analysis_result.risks[0].check_name, "Self-Destruct");
}

fn mock_empty_source_code_response() -> EtherscanApiResponse {
    let json = r#"
    {
        "status": "1",
        "message": "OK",
        "result": [
            {
                "SourceCode": "",
                "ABI": "Contract-ABI",
                "ContractName": "EmptyContract",
                "CompilerVersion": "v0.8.20+commit.a1b79de6",
                "OptimizationUsed": "1",
                "Runs": "200",
                "ConstructorArguments": "",
                "EVMVersion": "Default",
                "Library": "",
                "LicenseType": "MIT",
                "Proxy": "0",
                "Implementation": "",
                "SwarmSource": "ipfs://..."
            }
        ]
    }
    "#;
    serde_json::from_str(json).unwrap()
}

#[test]
fn test_analysis_with_empty_source_code() {
    let mock_response = mock_empty_source_code_response();
    let source_code = extract_true_source_code(&mock_response.result[0].source_code);
    let analysis_result = analyze_source_code(&source_code);

    assert_eq!(analysis_result.score, 100);
    assert!(analysis_result.risks.is_empty());
}

fn mock_tx_origin_response() -> EtherscanApiResponse {
    let json = r#"
    {
        "status": "1",
        "message": "OK",
        "result": [
            {
                "SourceCode": "pragma solidity ^0.8.0; contract Auth { function authenticate() public view { require(msg.sender == tx.origin); } }",
                "ABI": "Contract-ABI",
                "ContractName": "Auth",
                "CompilerVersion": "v0.8.20+commit.a1b79de6",
                "OptimizationUsed": "1",
                "Runs": "200",
                "ConstructorArguments": "",
                "EVMVersion": "Default",
                "Library": "",
                "LicenseType": "MIT",
                "Proxy": "0",
                "Implementation": "",
                "SwarmSource": "ipfs://..."
            }
        ]
    }
    "#;
    serde_json::from_str(json).unwrap()
}

#[test]
fn test_detects_tx_origin_vulnerability() {
    let mock_response = mock_tx_origin_response();
    let source_code = extract_true_source_code(&mock_response.result[0].source_code);
    let analysis_result = analyze_source_code(&source_code);

    assert_eq!(analysis_result.risks.len(), 1);
    assert_eq!(analysis_result.risks[0].check_name, "tx.origin Authentication");
    assert_eq!(analysis_result.score, 70); // 100 - 30 (High)
}

fn mock_timestamp_dependence_response() -> EtherscanApiResponse {
    let json = r#"
    {
        "status": "1",
        "message": "OK",
        "result": [
            {
                "SourceCode": "pragma solidity ^0.8.0; contract Lottery { function pickWinner() public { if (block.timestamp % 15 == 0) { } } }",
                "ABI": "Contract-ABI",
                "ContractName": "Lottery",
                "CompilerVersion": "v0.8.20+commit.a1b79de6",
                "OptimizationUsed": "1",
                "Runs": "200",
                "ConstructorArguments": "",
                "EVMVersion": "Default",
                "Library": "",
                "LicenseType": "MIT",
                "Proxy": "0",
                "Implementation": "",
                "SwarmSource": "ipfs://..."
            }
        ]
    }
    "#;
    serde_json::from_str(json).unwrap()
}

#[test]
fn test_detects_timestamp_dependence_vulnerability() {
    let mock_response = mock_timestamp_dependence_response();
    let source_code = extract_true_source_code(&mock_response.result[0].source_code);
    let analysis_result = analyze_source_code(&source_code);

    assert_eq!(analysis_result.risks.len(), 1);
    assert_eq!(analysis_result.risks[0].check_name, "Block Timestamp Dependency");
    assert_eq!(analysis_result.score, 85); // 100 - 15 (Medium)
}

fn mock_deprecated_functions_response() -> EtherscanApiResponse {
    let json = r#"
    {
        "status": "1",
        "message": "OK",
        "result": [
            {
                "SourceCode": "pragma solidity ^0.4.0; contract OldContract { function close() public { suicide(msg.sender); } }",
                "ABI": "Contract-ABI",
                "ContractName": "OldContract",
                "CompilerVersion": "v0.4.26+commit.a1b79de6",
                "OptimizationUsed": "1",
                "Runs": "200",
                "ConstructorArguments": "",
                "EVMVersion": "Default",
                "Library": "",
                "LicenseType": "MIT",
                "Proxy": "0",
                "Implementation": "",
                "SwarmSource": "ipfs://..."
            }
        ]
    }
    "#;
    serde_json::from_str(json).unwrap()
}

#[test]
fn test_detects_deprecated_functions_vulnerability() {
    let mock_response = mock_deprecated_functions_response();
    let source_code = extract_true_source_code(&mock_response.result[0].source_code);
    let analysis_result = analyze_source_code(&source_code);

    assert_eq!(analysis_result.risks.len(), 2);
    assert_eq!(analysis_result.score, 25); // 100 - 70 (Critical) - 5 (Low)

    assert!(analysis_result.risks.iter().any(|r| r.check_name == "Self-Destruct"));
    assert!(analysis_result.risks.iter().any(|r| r.check_name == "Outdated Compiler Version"));
}

// Mocks for Etherscan API responses will be added here. 